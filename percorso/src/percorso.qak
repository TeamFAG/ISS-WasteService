System systempercorso

Request  dopath   : dopath( PATH, OWNER )
Reply dopathdone  : dopathdone( ARG )
Reply dopathfail  : dopathfail( ARG )
Dispatch pathdone : pathdone( P )
Dispatch pathfail : pathdone( P )
 
Dispatch cmd       	: cmd(MOVE)     
//Dispatch end       	: end(ARG)  
 
Request step       : step( TIME )	
Reply   stepdone   : stepdone(V)  
Reply   stepfail   : stepfail(DURATION, CAUSE)

Event alarm     : alarm(X) 

Context ctxbasicrobot ip [host="127.0.0.1" port=8020] 
Context ctxpercorso ip [host="localhost" port=8030]

ExternalQActor basicrobot context ctxbasicrobot

/*
QActor tester context ctxpercorso {
	State s initial {
		println("init")
	}
	Goto doStep
	
	State doStep {
		request basicrobot -m step : step(350)
	}
	Transition t whenReply stepdone -> handleDone
				 whenReply stepfail -> handleFail
	
	State handleDone {
		println("Reply arrivata")
	}
	Goto doStep
	
	State handleFail {
		println("muro")
	}
}
* 
*/


QActor pathexecutor context ctxpercorso {
	[# var CurMoveTodo = "" #]
	
	State init initial {
		[# CurMoveTodo = "" #]
		println("\tPATHEXECUTOR | started")
	}
	Transition t0 whenRequest dopath -> doThePath
	
	State doThePath {
		onMsg(dopath : dopath(P, C)) {
			[# val path = payloadArg(0); println(path) #]
			[# pathut.setPath(path) #]
		}
		
		println("\tPATHEXECUTOR | pathTodo: ${pathut.getPathTodo()}")
	}
	Goto nextMove
	
	State nextMove {
		[# CurMoveTodo = pathut.nextMove() #]
		println("\tPATHEXECUTOR | curMoveTodo: $CurMoveTodo")
	}
	Goto endWorkOk if [# CurMoveTodo.length == 0 #] else doMove
	
	State doMove {
		//delay 300
	}
	Goto doMoveW if [# CurMoveTodo == "w" #] else doMoveTurn
	
	State doMoveTurn {
		forward basicrobot -m cmd : cmd($CurMoveTodo)
	}
	Transition t1 whenTime 300 -> nextMove
	
	State doMoveW {
		request basicrobot -m step : step(350)
	}
	Transition t2 whenEvent alarm -> handleAlarm
				  whenReply stepdone -> nextMove
				  whenReply stepfail -> endWorkKo
				  
	State handleAlarm {
		[# var PathTodo = pathut.getPathTodo() #]
		println("\tPATHEXECUTOR | handleAlarm ... pathTodo: $PathTodo")
	}
	
	State endWorkOk {
		println("\tPATHEXECUTOR | Path done - bye")
		replyTo dopath with dopathdone : dopathdone(ok)
	}
	Goto init
	
	State endWorkKo {
		[# var PathStillTodo = pathut.getPathTodo() #]
		println("\tPATHEXECUTOR | path failure - sorry. PathStillTodo: $PathStillTodo")
		replyTo dopath with dopathfail : dopathfail($PathStillTodo)
	}
	Transition t0 whenEvent alarm -> handleAlarm
}

QActor pathtester context ctxpercorso {
	[# var Actions: String = "" #]
	
	State init initial {
		println("LUIGI")
	}
	Goto  doPath
  				  
	State doPath{
		[#
			planner.initAI()
			planner.loadRoomMap("mapWithObst2019")
			planner.setGoal(4, 4)
			planner.doPlan()
			Actions = planner.getActionsString()			
		#]
		println("$Actions")
		println("doexplore starts $Actions")   
		request pathexecutor -m dopath : dopath( $Actions, tester )
	}
	Transition t0 whenReply dopathdone -> end
				  whenReply dopathfail -> handelPathFailure

    State handelPathFailure{
    	printCurrentMessage
 		emit alarm : alarm(obstacle) 		
	}
    State end{
    	println("BYE")
    }
}
  
 /*
QActor pathcaller context ctxpercorso {
 	State s0 initial{  
 		println("Pathcaller started")
	}
	Goto  doPath
  				  
	State doPath{
		[# val PathTodo =  "wwlwlwwlwl"  #]
		println("doexplore starts $PathTodo")   
		request pathexecutor -m dopath : dopath( $PathTodo, pathcaller )
	}
	Transition t0 whenReply dopathdone -> end
				  whenReply dopathfail -> handelPathFailure

	
     
    State handelPathFailure{
    	printCurrentMessage
 		emit alarm : alarm(obstacle) 		
	}
    State end{
    	println("BYE")
    }
   
}
* 
*/