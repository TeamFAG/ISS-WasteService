<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
    pre {
        border: 1px solid black;
        padding: 5px;
        white-space: -moz-pre-wrap;
        /* Mozilla, supported since 1999 */
        white-space: -pre-wrap;
        /* Opera */
        white-space: -o-pre-wrap;
        /* Opera */
        white-space: pre-wrap;
        /* CSS3 â€“ Text module (Candidate Recommendation) http://www.w3.org/TR/css3-text/#white-space */
        word-wrap: break-word;
        /* IE 5.5+ */
        border-radius: 8px;
    }

    pre code {
        padding: 0px;
    }

    pre code .line::before {
        content: counter(line-numbering);
        counter-increment: line-numbering;
        padding-right: .8em;
        /* space after numbers */
        margin-right: 5px;
        width: 1.5em;
        text-align: right;
        opacity: 0.5;
        background-color: #efefef;
    }

    body {
        margin-left: 30px;
        margin-right: 30px;
    }

    ;

    P {
        font-family: Tahoma;
        font-size: 10pt;
    }

    ;

    a,
    a:visited,
    a:active,
    a:link,
    a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }

    a:hover {
        background-color: #cccccc;
    }

    dd {
        margin-right: 50px;
        margin-bottom: 7px;
    }

    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }

    h1,
    h2,
    h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }

    top {
        width: 100%;
    }


    #i {
        color: #ff1010;
    }

    tt {
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }

    em {
        font-family: "Arial";
        font-size: 80%;
        font-weight: bold;
        border-style: solid;
        border-color: #abe876;
        color: #1632cc;
    }

    bc {
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
        background-color: #fcf8c7;
    }

    k {
        font-family: "Arial";
        font-weight: bold;
        color: #930000;
        font-size: 90%;
    }

    ks {
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD;
        font-size: 90%;
    }

    kc {
        font-family: "Arial";
        font-weight: bold;
        color: #008000;
        font-size: 90%;
    }

    ki {
        font-family: "Arial";
        color: #6d6d6d;
        font-weight: bold;
        font-size: 90%;
    }

    kl {
        font-family: "Arial";
        color: #ff21da;
        font-weight: bold;
        font-size: 90%;
    }

    pre {
        font-family: "Consolas";
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }

    m {
        font-family: "Helvetica";
        line-height: 100%;
        font-size: 75%;
    }

    div.body {
        font-size: 18px;
    }

    k {
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }


    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }

    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }

    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }

    h4 {
        background-color: #ccffcc;
        font-size: 100%;
        width: 98%;
        border-radius: 5px;
        padding: 5px;
    }

    h5 {
        background-color: #fff1b0;
        font-size: 100%;
        border-radius: 5px;
        padding: 5px;
    }

    ol, ol li {
        margin-left: 30px;
    }

    div.req {
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }

    div.remark {
        background-color: #E3F2FD;
        border: 1.5px solid #d5f2ed;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }

    table,
    th,
    td {
        border: 1px solid black;
        border-collapse: collapse;
    }

    ol,
    ul,
    li {
        margin: 0;
        margin-left: 10px;
        padding: 0;
        padding-bottom: 5px;
    }

    table,
    th,
    td {
        border: 1px solid black;
    }

    img {
        border: 1.5px solid #d5f2ed
    }

    a,
    a:visited,
    a:active,
    a:link,
    a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
    }

    div.wrapdesc {
        width: 90%;
        margin: auto;
    }

    div.imagedesc {
        width: 85%;
        margin: auto;
    }

    .center {
        display: block;
        margin-left: auto;
        margin-right: auto;
        width: 50%;
    }
</style>

<head>
    <title>Waste Service - Sprint1</title>
</head>

<body>
    <div id="top">
        <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font>
        </h1>
    </div>

    <div class="body">
        <h2>Introduction</h2>
        <div class="remark">
            <h3>SCRUM goal</h3>
            In the Sprint1 we aim to analyze the problems linked to the modeling of the core service and, ultimately, create a functioning prototype.<br/>
            <br/>
            <h4>Core Service</h4>
            <img src="./imgs/systemarchitecturearch_core.png" alt="SystemArch" style="width:auto;height:750px;" class="center"><br/>
            The core service is identified by the following elements:
            <ul><br/>
                <li>Wasteservice</li>
                <li>Transport Trolley</li>
                <li>Waste Truck/Driver</li>
            </ul>
            
        </div>

        <h2>Requirements</h2>
        <div class="remark">
            <a
                href="https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/TemaFinale22.html">
                TemaFinale22
            </a>
            <br/>
            <a href="../../sprint0/userDocs/WasteService.html">Sprint0</a>
        </div>

        <h2>Problem analysis</h2>
        <div class="remark">

            <h3>Map and Trolley movement</h3>

            The first problem we are going to tackle is how the transport trolley/DDR robot moves within the space of the service.<br/>
            The customer has given us an image of the layout but, for obvious reasons, the robot cannot understand them, so it has no idea where
            to go or what to look for.

            We can theorize some solutions to this problem:
            <ol>
                <li><h4>Without Map Coordinates</h4>
                    This solution requires no planning, as it uses the specified layout given by the customer to move the trolley.<br/>
                    By abusing the fact that all points of interest are located on a wall adjacent to a corner, all the robot needs to do is 
                    move along the walls and find the target by colliding with it.<br/>
                    If, by chance, the trolley received a different command, it would just need to turn in the right direction/orientation and keep moving.

                    <img src="./imgs/MapWoCoord.svg" alt="mapWoCoord" height="400px" class="center">
                    
                    <k>PROS</k>
                    <ul>
                        <li>Easily scalable to all room sizes.</li>
                        <li>No need for prior room mapping of coordinates.</li>
                    </ul>
                    <k>CONS</k>
                    <ul>
                        <li>The movement logic is strictly tied to the layout. Even the smallest change would
                            require a lot of work, making this solution not flexible.
                        </li>
                        <li>Determining the complete logic is a complex problem.</li>
                    </ul>
                    
                </li>
                <li><h4>With Map Coordinates</h4>
                    This solution uses pre-determined coordinates to move the trolley.<br/>
                    To use the coordinates, the room is divided into squares with dimensions based on <b>RD</b> using a mapper.<br/>
                    Then, each point of interest (HOME, INDOOR, PLASTICBOX, GLASSBOX) is assigned to some of the coordinates.<br/>
                    <br/>

                    <img src="./imgs/MapWCoord.drawio.svg" alt="mapWCoord" height="400px" class="center">

                    The customer provides 3 useful tools:
                    <ol>
                        <li><a href="https://github.com/anatali/issLab2022/tree/main/unibo.mapperQak22"><b>unibo.mapperQak22</b></a>: Creates a map of the room in the form of a string by moving the robot around and saving movement and collision data.</li>
                        <li><a href="https://github.com/anatali/issLab2022/tree/main/unibo.planner22"><b>unibo.planner22</b></a>: Finds a path for the robot by using target coordinates.</li>
                        <li><a href="https://github.com/anatali/issLab2022/tree/main/unibo.pathexecutor"><b>unibo.pathexecutor</b></a>: Moves the robot along a certain pre-determined path.</li>
                    </ol>

                    <k>PROS</k>
                    <ul>
                        <li>Easily scalable to all room layouts.</li>
                        <li>Easy to implement, as the customer provides a lot of useful software.</li>
                    </ul>
                    <k>CONS</k>
                    <ul>
                        <li>Mapping the room and assigning coordinates takes time.</li>
                        <li>The room's dimensions might not be multiples of <b>RD</b>, so additional movements may be required to reach all points of interest.</li>
                    </ul>   
                </li>
            </ol>

            We decided to opt for the second solution because it's easier to implement while also having a higher maintainability, reusability and extencibility. <br/>
            In the first place, it's necessary to further introduce the tools provided by the customer that will be used to solve the problem:<br/>
            <h5>mapperQak22</h5>

            <dd>
                <img src="./imgs/mapperqak22arch.png" alt="mapperQak" style="width:auto;height:400px;" class="center">

                The mapper is qak actor and provides us a map of the room in which the system will operate. It works by communicating with the real/virtual robot (starting from the HOME position)
                and making it move inside the room while keeping track of its layout and dimensions.<br/>
                Once the robot has explored the whole room, mapperQak22 stops sending commands and saves the resulting map in two files with different types:
                <ol>
                    <li>().txt which is useful to show the map layout.</li>
                    <li>().bin will be used later by the planner.</li>
                </ol>
                The robot maps the room giving it dimensions based on it's size (RD). When the dimensions of the rectangular map are not multiple of RD, the 
                excesses are still counted are still counted as a full step.<br/>
                As of now, this seems to be a good way to map the service area.
            </dd>
            
            <h5>planner22</h5>

            <dd>
                The planner is a Kotlin object that uses the binary map file previously mentioned to search for the best possible path (series of moves) to reach a certain point of the map 
                from the current position.<br/>
                The methods provided are summarized in the following interface:
                
                <img src="./imgs/planner-interface.drawio.svg" alt="mapperQak" style="width:auto;height:250px;" class="center">

                <ul>
                    <li><b>initAI</b>: initialize a breadth-first algorithm used to plan the best path.</li>
                    <li><b>loadRoomMap</b>: loads the binary map file, assuming the robot position in [0,0].</li>
                    <li><b>showMap</b>: shows a visual array representation of the current state of the map.</li>
                    <li><b>setGoal</b>: sets the goal position in coordinates.</li>
                    <li><b>doPlan</b>: uses the AI to plan the best path from the current position to the goal.</li>
                    <li><b>startTimer</b>: starts a timer.</li>
                    <li><b>getDuration</b>: returns the time passed from the last start of the timer.</li>
                </ul>
            </dd>

            <h5>pathexecutor</h5>

            <dd>
                <!--TODO: immagine-->
                
                The path executor uses a string that symbolizes the movements (in the aril language) and comunicates with the robot accordingly to accomplish the task.<br/>
                Currently this string is hard-coded, we intend to use the planner to get this string and send it to this actor. We will later define this methods.
            </dd>

            <h4>Assigning points of interest to coordinates on the map</h4>
            <!--TODO: how to map the points of interest-->
            
                After generating the map, we have to assign all points of interest (HOME, INDOOR, PLASTIC BOX, GLASS BOX) to the coordinates.<br/>
                Considering the image provided by the customer, we can see that HOME is a space on the floor; however, the other points are mapped
                on the walls.<br/><br/>

                <b>How can we decide when the trolley is interacting with these points ?</b><br/>
                We have decided that <b><i>if the robot enters the spaces adjacent to the walls and faces towards those walls, then it is
                able to interact with them</i></b>.<br/><br/>

                As an example, let's take a map generated by mapperQak22 using the virtual robot environment:<br/>
                <pre><code>
|r, 1, 1, 1, 1, 1, 1, 
|1, 0, 0, 0, 0, 0, 1, 
|1, 0, 0, 0, 0, 0, 1, 
|1, 0, 0, 0, 0, 0, 1, 
|1, 1, 1, 1, 1, 1, 1, 
                </code></pre>
                Where the 1s represent spaces adjacent to walls and 0s represent the inside of the room.<br/>
                r is the robot in its HOME position.
                
                For now, these are the sizes and general positions of all points of interest based on the general coordinates of a map:

                <div class="center">
                    <table class="center">
                        <tr>
                            <th>Name</th>
                            <th>Size</th>
                            <th>Position</th>
                        </tr>
                        <tr>
                            <td><center>HOME</center></td>
                            <td><img src="./imgs/1x1.drawio.svg" alt="1x1" class="center"></td>
                            <td>
                                <pre><code>
    |X, 1, 1, 1, 1, 1, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 1, 1, 1, 1, 1, 1, 
                                </code></pre>
                            </td>
                        </tr>
                        <tr>
                            <td><center>INDOOR</center></td>
                            <td><img src="./imgs/3x1.drawio.svg" alt="3x1" class="center"></td>
                            <td>
                                <pre><code>
    |1, 1, 1, 1, 1, 1, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |X, X, X, 1, 1, 1, 1, 
                                </code></pre>
                            </td>
                        </tr>
                        <tr>
                            <td><center>PLASTIC BOX</center></td>
                            <td><img src="./imgs/1x3.drawio.svg" alt="1x3" class="center"></td>
                            <td>
                                <pre><code>
    |1, 1, 1, 1, 1, 1, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, X, 
    |1, 0, 0, 0, 0, 0, X, 
    |1, 1, 1, 1, 1, 1, X, 
                                </code></pre>
                            </td>
                        </tr>
                        <tr>
                            <td><center>GLASS BOX</center></td>
                            <td><img src="./imgs/3x1.drawio.svg" alt="3x1" class="center"></td>
                            <td>
                                <pre><code>
    |1, 1, 1, 1, X, X, X, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 1, 1, 1, 1, 1, 1, 
                                </code></pre>
                            </td>
                        </tr>
                    </table>
                </div>
                
                <h5><k>WARNING:</k> these definitions are based on a rough image and could be subject to change.</h5><br/>
                Moreover, this information could be hardcoded in the system, however we thought it would be better to create
                a configuration file in case these definitions have to be change (we have also considered the option to 
                generate the file as part of the mapping process).<br/><br/>

                The following is an example of that configuration file created for the initial map in the virtual robot environment:
                
                <pre><code>
{ 
    "positions": {
        "home" : [
            [0, 0]
        ],
        "indoor": [
            [0, 4], [1, 4], [2, 4]
        ],
        "glassbox": [
            [4, 0], [5, 0], [6, 0]
        ],
        "plasticbox": [
            [6, 2], [6, 3], [6, 4]
        ]
    }
}                    
                </code></pre>
            </dd>

            <!--TODO: description of the method that connects to the executor-->
            getActionsString

            <!--TODO: updated model for this ineteraction-->
            Move(location) needs to be a request because the trolley has to know when the robot is moving to manage queued requests.
            This is done via the moveDone reply. Also, testing biatch.#0000CD

            We decided to also include a halt.

            The robot finishes the current move before handling the stop request.
        </div>

        <h2>Work plan</h2>
      

    </div>

    <!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->

    <br /><br />
    </div>

    <div style="background-color:rgba(185, 180, 215, 0.9); width:100%;text-align:center;color:white">
        By <a href="https://github.com/TeamFAG/ISS-WasteService">TeamFAG</a>: <br />
        <a href="https://github.com/Federicoand98">federico.andrucci@studio.unibo.it</a>,<br />
        <a href="https://github.com/Noesh">alex.gianelli@live.it</a>,<br />
        <a href="https://github.com/Stikinit">gabriele.marconi@studio.unibo.it</a>,<br />

        <br />

        <table>
            <tr>
                <th>
                    Federico Andrucci
                </th>
                <th>
                    Alex Gianelli
                </th>
                <th>
                    Gabriele Marconi
                </th>
            </tr>
            <tr>
                <td>
                    <img src="./imgs/federico-andrucci.jpg" alt="f" style="width:300;height:auto;" class="center">
                </td>
                <td>
                    <img src="./imgs/alex-gianelli.jpg" alt="a" style="width:300;height:auto;" class="center">
                </td>
                <td>
                    <img src="./imgs/gabriele-marconi.jpg" alt="g" style="width:300;height:auto;" class="center">
                </td>
            </tr>
        </table>
    </div>
</body>

</html>