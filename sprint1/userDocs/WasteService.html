<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
    pre {
        border: 1px solid black;
        padding: 5px;
        white-space: -moz-pre-wrap;
        /* Mozilla, supported since 1999 */
        white-space: -pre-wrap;
        /* Opera */
        white-space: -o-pre-wrap;
        /* Opera */
        white-space: pre-wrap;
        /* CSS3 â€“ Text module (Candidate Recommendation) http://www.w3.org/TR/css3-text/#white-space */
        word-wrap: break-word;
        /* IE 5.5+ */
        border-radius: 8px;
    }

    pre code {
        padding: 0px;
    }

    pre code .line::before {
        content: counter(line-numbering);
        counter-increment: line-numbering;
        padding-right: .8em;
        /* space after numbers */
        margin-right: 5px;
        width: 1.5em;
        text-align: right;
        opacity: 0.5;
        background-color: #efefef;
    }

    body {
        margin-left: 30px;
        margin-right: 30px;
    }

    ;

    P {
        font-family: Tahoma;
        font-size: 10pt;
    }

    ;

    a,
    a:visited,
    a:active,
    a:link,
    a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }

    a:hover {
        background-color: #cccccc;
    }

    dd {
        margin-right: 50px;
        margin-bottom: 7px;
    }

    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }

    h1,
    h2,
    h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }

    top {
        width: 100%;
    }


    #i {
        color: #ff1010;
    }

    tt {
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }

    em {
        font-family: "Arial";
        font-size: 80%;
        font-weight: bold;
        border-style: solid;
        border-color: #abe876;
        color: #1632cc;
    }

    bc {
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
        background-color: #fcf8c7;
    }

    k {
        font-family: "Arial";
        font-weight: bold;
        color: #930000;
        font-size: 90%;
    }

    ks {
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD;
        font-size: 90%;
    }

    kc {
        font-family: "Arial";
        font-weight: bold;
        color: #008000;
        font-size: 90%;
    }

    ki {
        font-family: "Arial";
        color: #6d6d6d;
        font-weight: bold;
        font-size: 90%;
    }

    kl {
        font-family: "Arial";
        color: #ff21da;
        font-weight: bold;
        font-size: 90%;
    }

    pre {
        font-family: "Consolas";
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }

    m {
        font-family: "Helvetica";
        line-height: 100%;
        font-size: 75%;
    }

    div.body {
        font-size: 18px;
    }

    k {
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }


    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }

    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }

    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }

    h4 {
        background-color: #ccffcc;
        font-size: 100%;
        width: 98%;
        border-radius: 5px;
        padding: 5px;
    }

    h5 {
        background-color: #fff1b0;
        font-size: 100%;
        border-radius: 5px;
        padding: 5px;
    }

    ol, ol li {
        margin-left: 30px;
    }

    div.req {
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }

    div.remark {
        background-color: #E3F2FD;
        border: 1.5px solid #d5f2ed;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }

    table,
    th,
    td {
        border: 1px solid black;
        border-collapse: collapse;
    }

    ol,
    ul,
    li {
        margin: 0;
        margin-left: 10px;
        padding: 0;
        padding-bottom: 5px;
    }

    table,
    th,
    td {
        border: 1px solid black;
    }

    img {
        border: 1.5px solid #d5f2ed
    }

    .noborder {
        border: 1px solid rgba(0, 0, 0, 0);
    }

    a,
    a:visited,
    a:active,
    a:link,
    a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
    }

    div.wrapdesc {
        width: 90%;
        margin: auto;
    }

    div.imagedesc {
        width: 85%;
        margin: auto;
    }

    .center {
        display: block;
        margin-left: auto;
        margin-right: auto;
        width: 50%;
    }
</style>

<head>
    <title>Waste Service - Sprint1</title>
</head>

<body>
    <div id="top">
        <h1>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE <font size="5"></font>
        </h1>
    </div>

    <div class="body">
        <h2>Introduction</h2>
        <div class="remark">
            <h3>SCRUM goal</h3>
            In the Sprint1 we aim to analyze the problems linked to the modeling of the core service and, ultimately, create a functioning prototype.<br/>
            <br/>
            <h4>Core Service</h4>
            <img src="./imgs/systemarchitecturearch_core.png" alt="SystemArch" style="width:auto;height:750px;" class="center"><br/>
            The core service is identified by the following elements:
            <ul><br/>
                <li>Wasteservice</li>
                <li>Transport Trolley</li>
                <li>Waste Truck/Driver</li>
            </ul>
            
        </div>

        <h2>Requirements</h2>
        <div class="remark">
            <a
                href="https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/TemaFinale22.html">
                TemaFinale22
            </a>
            <br/>
            <a href="../../sprint0/userDocs/WasteService.html">Sprint0</a>
        </div>

        <h2>Problem analysis</h2>
        <div class="remark">

            <h3>Map and Trolley movement</h3>

            The first problem we are going to tackle is how the transport trolley/DDR robot moves within the space of the service.<br/>
            The customer has given us an image of the layout but, for obvious reasons, the robot cannot understand them, so it has no idea where
            to go or what to look for.

            We can theorize some solutions to this problem:
            <ol>
                <li><h4>Without Map Coordinates</h4>
                    This solution requires no planning, as it uses the specified layout given by the customer to move the trolley.<br/>
                    By abusing the fact that all points of interest are located on a wall adjacent to a corner, all the robot needs to do is 
                    move along the walls and find the target by colliding with it.<br/>
                    If, by chance, the trolley received a different command, it would just need to turn in the right direction/orientation and keep moving.

                    <img src="./imgs/MapWoCoord.svg" alt="mapWoCoord" height="400px" class="center">
                    
                    <k>PROS</k>
                    <ul>
                        <li>Easily scalable to all room sizes.</li>
                        <li>No need for prior room mapping of coordinates.</li>
                    </ul>
                    <k>CONS</k>
                    <ul>
                        <li>The movement logic is strictly tied to the layout. Even the smallest change would
                            require a lot of work, making this solution not flexible.
                        </li>
                        <li>Determining the complete logic is a complex problem.</li>
                    </ul>
                    
                </li>
                <li><h4>With Map Coordinates</h4>
                    This solution uses pre-determined coordinates to move the trolley.<br/>
                    To use the coordinates, the room is divided into squares with dimensions based on <b>RD</b> using a mapper.<br/>
                    Then, each point of interest (HOME, INDOOR, PLASTICBOX, GLASSBOX) is assigned to some of the coordinates.<br/>
                    <br/>

                    <img src="./imgs/MapWCoord.drawio.svg" alt="mapWCoord" height="400px" class="center">

                    The customer provides 3 useful tools:
                    <ol>
                        <li><a href="https://github.com/anatali/issLab2022/tree/main/unibo.mapperQak22"><b>unibo.mapperQak22</b></a>: Creates a map of the room in the form of a string by moving the robot around and saving movement and collision data.</li>
                        <li><a href="https://github.com/anatali/issLab2022/tree/main/unibo.planner22"><b>unibo.planner22</b></a>: Finds a path for the robot by using target coordinates.</li>
                        <li><a href="https://github.com/anatali/issLab2022/tree/main/unibo.pathexecutor"><b>unibo.pathexecutor</b></a>: Moves the robot along a certain pre-determined path.</li>
                    </ol>

                    <k>PROS</k>
                    <ul>
                        <li>Easily scalable to all room layouts.</li>
                        <li>Easy to implement, as the customer provides a lot of useful software.</li>
                    </ul>
                    <k>CONS</k>
                    <ul>
                        <li>Mapping the room and assigning coordinates takes time.</li>
                        <li>The room's dimensions might not be multiples of <b>RD</b>, so additional movements may be required to reach all points of interest.</li>
                    </ul>   
                </li>
            </ol>

            We decided to opt for the second solution because it's easier to implement while also having a higher maintainability, reusability and extencibility. <br/>
            In the first place, it's necessary to further introduce the tools provided by the customer that will be used to solve the problem:<br/>
            

            <h4>Assigning points of interest to coordinates on the map</h4>
            
                After generating the map, we have to assign all points of interest (HOME, INDOOR, PLASTIC BOX, GLASS BOX) to the coordinates.<br/>
                Considering the image provided by the customer, we can see that HOME is a space on the floor; however, the other points are mapped
                on the walls.<br/><br/>

                <b>How can we decide when the trolley is interacting with these points ?</b><br/>
                We have decided that <b><i>if the robot enters the spaces adjacent to the walls and faces towards those walls, then it is
                able to interact with them</i></b>.<br/><br/>

                As an example, let's take a map generated by mapperQak22 using the virtual robot environment:<br/>
                <pre><code>
|r, 1, 1, 1, 1, 1, 1, 
|1, 0, 0, 0, 0, 0, 1, 
|1, 0, 0, 0, 0, 0, 1, 
|1, 0, 0, 0, 0, 0, 1, 
|1, 1, 1, 1, 1, 1, 1, 
                </code></pre>
                Where the 1s represent spaces adjacent to walls and 0s represent the inside of the room.<br/>
                r is the robot in its HOME position.
                
                For now, these are the sizes and general positions of all points of interest based on the general coordinates of a map:

                <div class="center">
                    <table class="center">
                        <tr>
                            <th>Name</th>
                            <th>Size</th>
                            <th>Position</th>
                        </tr>
                        <tr>
                            <td><center>HOME</center></td>
                            <td><img src="./imgs/1x1.drawio.svg" alt="1x1" class="center"></td>
                            <td>
                                <pre><code>
    |X, 1, 1, 1, 1, 1, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 1, 1, 1, 1, 1, 1, 
                                </code></pre>
                            </td>
                        </tr>
                        <tr>
                            <td><center>INDOOR</center></td>
                            <td><img src="./imgs/3x1.drawio.svg" alt="3x1" class="center"></td>
                            <td>
                                <pre><code>
    |1, 1, 1, 1, 1, 1, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |X, X, X, 1, 1, 1, 1, 
                                </code></pre>
                            </td>
                        </tr>
                        <tr>
                            <td><center>PLASTIC BOX</center></td>
                            <td><img src="./imgs/1x3.drawio.svg" alt="1x3" class="center"></td>
                            <td>
                                <pre><code>
    |1, 1, 1, 1, 1, 1, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, X, 
    |1, 0, 0, 0, 0, 0, X, 
    |1, 1, 1, 1, 1, 1, X, 
                                </code></pre>
                            </td>
                        </tr>
                        <tr>
                            <td><center>GLASS BOX</center></td>
                            <td><img src="./imgs/3x1.drawio.svg" alt="3x1" class="center"></td>
                            <td>
                                <pre><code>
    |1, 1, 1, 1, X, X, X, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 0, 0, 0, 0, 0, 1, 
    |1, 1, 1, 1, 1, 1, 1, 
                                </code></pre>
                            </td>
                        </tr>
                    </table>
                </div>
                
                <h5><k>WARNING:</k> these definitions are based on a rough image and could be subject to change.</h5><br/>
                Moreover, this information could be hardcoded in the system, however we thought it would be better to create
                a configuration file in case these definitions have to be change (we have also considered the option to 
                generate the file as part of the mapping process).<br/><br/>

                The following is an example of that configuration file created for the initial map in the virtual robot environment:
                
                <pre><code>
{ 
    "positions": {
        "home" : [
            [0, 0]
        ],
        "indoor": [
            [0, 4], [1, 4], [2, 4]
        ],
        "glassbox": [
            [4, 0], [5, 0], [6, 0]
        ],
        "plasticbox": [
            [6, 2], [6, 3], [6, 4]
        ]
    }
}                    
                </code></pre>
            </dd>

            <h3>wasteservice</h3>
            <dd>
                The second problem in the core service is how wasteservice manages information from and to the other entities
                (the truck and the trolley).
                Based on the requirements for the project, we can pose the following questions:
                <ol>
                    <li>When do we notify the driver of a successfull pickup action ?</li>
                    <li>Who notifies the driver of a successfull pickup action ?</li>
                    <li>When can we update the amount of material inside the containers ?</li>
                </ol>
                
                <h4>Driver interaction timing</h4>
                In the previous Sprint we modeled the interaction so that loadAccepted and loadRejected both arrive immidiately
                to the driver after the storeRequest.

                <img src="./imgs/wasteservice-old.excalidraw.svg" alt="mapWoCoord" height="200px" class="center" style="padding: 20px;">
                
                However, with this solution it is impossible to know when the trolley picks-up the load without adding another message.<br/>
                <br/>
                So, for the sake of efficiency, we can delay the loadAccepted reply to when the trolley does the pickup action.<br/>
                <br/>
                As a consequence of this decision, the entity who will notify the driver of a successfull pick-up action is 
                wasteservice.<br/>
                This can be easily achieved by changing the notifyDeposit dispatch (defined in Sprint0) into a Request so 
                that its Reply can be sent to the wasteservice once the trolley picks-up the load.
                <pre><code>
    Request depositRequest : depositRequest(MATERIAL, QUANTITY)
    Reply pickupDone : pickupDone(RESULT)
                </code></pre>

                <img src="./imgs/wasteservice-new.excalidraw.svg" alt="mapWoCoord" height="200px" class="center" style="padding: 20px;">

                <h4>Container status update</h4>

                The next issue to discuss is choosing the appropriate moment to update the status of the containers in the system.<br/>
                The amount of material stored in each container is managed and monitored by the wasteservice actor, who has to make sure
                that the current weight doesn't exceed MAXPB and MAXGB.<br/><br/>
                
                The first and most obvious answer is to update the weight after the trolley has completed the deposit action.<br/>
                However, there is a major flaw with this solution: the transit of the trolley and the deposit of the load both take time, 
                in the meanwhile another storeRequest can be requested and we don't know if we can accept it.<br/>
                As a solution, instead of using the amount of material inside the containers, to check the storage feasibility we can consider
                the current load inside the system instead.

            </dd>

            <h3>wastetruck</h3>
            <dd>
                Previously our wastetruck was an actor, but our intentions in this Sprint are to implement a smartDevice application and use that 
                to interact with the wasteservice system.</br>
                As a consequence, the wastetruck is going to be any external user that can access the smartDevice.
            </dd>

            <h4>Customer's software</h4>
            <h5>mapperQak22</h5>
            <dd>
                <img src="./imgs/mapperqak22arch.png" alt="mapperQak" style="width:auto;height:400px;" class="center">

                The mapper is qak actor and provides us a map of the room in which the system will operate. It works by communicating with the real/virtual robot (starting from the HOME position)
                and making it move inside the room while keeping track of its layout and dimensions.<br/>
                Once the robot has explored the whole room, mapperQak22 stops sending commands and saves the resulting map in two files with different types:
                <ol>
                    <li>().txt which is useful to show the map layout.</li>
                    <li>().bin will be used later by the planner.</li>
                </ol>
                The robot maps the room giving it dimensions based on it's size (RD). When the dimensions of the rectangular map are not multiple of RD, the 
                excesses are still counted are still counted as a full step.<br/>
                As of now, this seems to be a good way to map the service area.
            </dd>
            
            <h5>planner22</h5>

            <dd>
                The planner is a Kotlin object that uses the binary map file previously mentioned to search for the best possible path (series of moves) to reach a certain point of the map 
                from the current position.<br/>
                The methods provided are summarized in the following interface:
                
                <img src="./imgs/planner-interface.drawio.svg" alt="mapperQak" style="width:auto;height:250px;" class="center">

                <ul>
                    <li><b>initAI</b>: initialize a breadth-first algorithm used to plan the best path.</li>
                    <li><b>loadRoomMap</b>: loads the binary map file, assuming the robot position in [0,0].</li>
                    <li><b>showMap</b>: shows a visual array representation of the current state of the map.</li>
                    <li><b>setGoal</b>: sets the goal position in coordinates.</li>
                    <li><b>doPlan</b>: uses the AI to plan the best path from the current position to the goal.</li>
                    <li><b>startTimer</b>: starts a timer.</li>
                    <li><b>getDuration</b>: returns the time passed from the last start of the timer.</li>
                </ul>
            </dd>

            <h5>pathexecutor</h5>

            <dd>
                <!--TODO: immagine-->
                
                The path executor uses a string that symbolizes the movements (in the aril language) and comunicates with the robot accordingly to accomplish the task.<br/>
                Currently this string is hard-coded, we intend to use the planner to get this string and send it to this actor. We will later define this methods.
            </dd>
                
            <br/>
            <h3>Current system architecture</h3>
            <div class="remark" style="background-color: #91a0ff;">
                <img src="./imgs/wasteservice_problem_analysisarch.png" alt="waasteserviceProblemArch" style="width:auto;height:450px;" class="center">
                </br>
                <a href="../sprint1_problem/src/architecture_problem_analysis.qak">Complete QAK Model Wasteservice</a>
                <br>
                <a href="../sprint1_problem/src/transporttrolley.qak">Transporttrolley QAK</a>
                <br>
                <a href="../sprint1_problem/src/wasteservice.qak">Wasteservice QAK</a>

                <br/>
                <h5>Test Plans</h5>
                <dd>
                    We have prepared the following tests for this particular model:
                    <ol>
                        <li><a href="../sprint1_problem/test/it.unibo.sprint1.test/TestWasteservice.kt">TestWasteservice.kt</a>: it checks the functioning of the storeRequest and the 
                            following replies.</li>
                        <li><a href="../sprint1_problem/test/it.unibo.sprint1.test/TestTransporttrolley.kt">TestTransporttrolley.kt</a>: it checks the correct execution of the transporttrolley's basic behavior.</li>
                    </ol>
                </dd>
            </div>
        </div>
        <h2>Project</h2>
        <div class="remark">
            <h3>Map and Trolley movement: resulting model</h3>

            The following section describes the model created following the problem analysis for the movement of the robot
            inside the room of the system.<br/>
            It uses the coordinate strategy and all previously mentioned tools provided by the customer (some of them have been modified
            and will be discussed shortly).<br/>
            As for the previous models, it was created using the QAK modeling language and its code can be found here: <a href="../sprint1_project/src/demo.qak">demo.qak</a> 

            <a href="../sprint1_project/src/demo.qak"><img src="./imgs/project-architecture.png" alt="demo" style="width:auto;height:450px;" class="center"> </a>

            <h3>Transporttrolley</h3>
            <!--
                1) perche viene progettato prima il tt rispetto a ws?
                2) visto che nel progetto abbiamo scelto le coordinate, come si vuole organizzare il ciÃ²?
                3) perchÃ¨ trolleymover? -> progetto mover (in toto, parlando anche del planner, in quanto utilizzato sia da mover che da pather)
                4) come Ã¨ stato adattato il pather per l'interrupted movement
                5) integrazione mover-trolley-robot
                
                1- complesso, elemento piÃ¹ grande dello sprint1, core problem piÃ¹ problematico
                2- dato che sono state scelte le coordinate abbiamo bisogno di qualcosa che possa muovere il trolley in quelle coordinate.
                    Quindi, fondamentale Ã¨ l'utilizzo di mapper per ottenere le coordinate della mappa, il pathexecutor che effettivamente sposta il trolley
                    in una determinata posizione, il planner per ottenere una serie di mosse a partire dalla posizione iniziale per arrivare ad una data destinazione.
                    Quindi per introdurre del disaccoppiamento tra i componenti abbiamo deciso di sviluppare il mover che rende invisibile al transporttrolley
                    ciÃ² che Ã¨ necessario per muoversi.

            -->
            <ol>
                <li><k>transporttrolley</k>
                    <dd>
                        We started with the transporttrolley project due to the fact that is (in our opinion) the largest, most complex and sensible to change
                        part of the architecture. <br/>
                        In view of our previous choice to use coordinates, we needed to use something to move the robot accordingly. So, after using the mapper to obtain and 
                        set the coordinates of our points of interest, we implemented our transporttrolley actor as simple and <i>placeholder</i> <!--TODO: indifferente, astratto (detached)--> 
                        as possible. <br/>
                        His previous behavior (seen in the problem analysis) didn't correspond to its intended one, as it was done only for testing purposes.
                        He does now manage the whole routine (HOME -> INDOOR -> BOX -> HOME) to properly handle the deposit requests he recieves, even when consecutive.
                        He does so by making requests to our new trolleymover actor by only specifying the location to reach, unencumbered by the modality. <br/>
                    </dd>
                </li>
                <li><k>trolleymover</k>
                    <dd>
                        Trolleymover handles this path in the following sequence:
                        <ul>
                            <dd>
                                <li>
                                    Gets the nearest coordinate of the target location thanks to our <a href="#utils">utils</a> method <i>getClosestCoordinate</i>.
                                </li>
                                <li>
                                    Uses the planner to calculate the path to the coordinate.
                                </li>
                                <li>
                                    Relays the path string to the <i>pather</i> and, if needed, in this state can handle a "path switch" (later discussed).
                                </li>
                            </dd>
                        </ul>
                    </dd>
                </li>
                <li><k>pather</k>
                    <dd>
                        Our version of the actor pathexecutor (called <!-- TODO: generare e linkare il file Qak singolo --> pather) has two main new features:
                        <ul>
                            <dd>
                                <li>
                                    Continuously updates the status of the virtual map, based on the robot's current position and the next move to execute.
                                </li>
                                <li>
                                    It now can easily react to the previously mentioned "path switch".
                                </li>
                            </dd>
                        </ul>
                        Also, to avoid a bug inside basicrobot that skips some steps, we introduced more delays.
                    </dd>
                </li>
            </ol>
            <dd>
                <h4>Path Switching</h4>
                During the development of this model, we encountered the issue of stopping the robot during the ongoing path.<br/>
                This can happen when the trolley is moving towards HOME, as part of its normal routine, and a new deposit needs to be handled.<br/>
                So the robot should stop moving and calculate a new path from the current position towards INDOOR.<br/><br/>

                As a sub-part of this problem we encountered the issue of constantly knowing the current position of the robot.<br/>
                Thankfully, the planner provides the method <i>updateMap</i> to keep track of the robot's position and rotation after each move.<br/>
                Consequently we are able to use the planner itself to substitute the current path with a newly calculated one whenever it's required.<br/><br/>

                Our new models now include some new states to make this possible.
            </dd>
            
            <h3>Wasteservice</h3>


            <h3>Smartdevice</h3>

          
            <h4>Other changes</h4>
            <k>pathplanner</k><br/>
            <dd>
                The planner was also modified from the original version provided by the customer.<br/>
                The only changes were the addition of using our new class <b>Coordinate</b> and the method <i>getActionsString</i>,
                that takes a generated path (a list of moves) and converts it into a single string, as required by the pather.<br/>
                <pre><code>
[w,l,w,w,r,r,w,w]   =>   "wlwwrrww" 
                </code></pre> 
            </dd>

            <h4>Assigning coordinates during the mapping phase</h4>
            <k>Config file</k><br/>
            <dd>
                We use a json file to store the positions of each important location in the map with the same format seen
                previously.<br/><br/>
                Initially, the target location is in string format (HOME, INDOOR, ecc...), and it's necessary to convert that information
                into coordinates.

                To do this, we introduced two kotlin files:
                <ul>
                    <li><k><a href="../resources/SystemConfig.kt">SystemConfig.kt</a></k>
                        <dd>
                            This object contains the coordinate information for each location in the map, obtained by reading the
                            json config file during the system's initialization.
                            
<pre><code>[# 
    (...)
    SystemConfig.setTheConfiguration("SystemConfiguration")
    planner.initAI()
    planner.loadRoomMap("mapRoomEmpty")
#]</code></pre>

                        </dd>
                    </li>
                    <li id="utils"><k><a href="../resources/utils.kt">utils.kt</a></k>
                        <dd>
                            This object handles the coordinate information with these two methods:
                            <ol>
                                <li><b><i>getMapCoord</i></b> returns all coordinate positions of one location thanks to <b>SystemConfig</b>.</li>
                                <li><b><i>getClosestCoordinate</i></b> uses the current position of the robot and a location name to determine 
                                the single coordinate of that location that is closest to the robot.</li><br/>
<pre><code>[#
    var coord: Coordinate = utils.getClosestCoordinate(planner.get_curCoord(), LOC)
    planner.setGoal(coord.x, coord.y)
    planner.doPlan()
    Actions = planner.getActionsString()
    (...)
#]</code></pre>                                     
                                <li><b><i>getLocationFromMaterialType</i></b> returns the name of the target location given the material.</li><br/>
                            </ol>
                        </dd>
                    </li>
                </ul>
            </dd>

            <h3>smartDevice</h3>
            <br>
                We also have developed a simple GUI application in python to simulate the interaction between the wastetruck and the wasteservice.</br>

                <img src="./imgs/truck-gui.jpg">

                From the top menu it's possible to choose the different material options (currently only PLASTIC and GLASS) and to specify the weight
                of the load. Pushing the button it sends a TCP request to the wasteservice end-point and the consequent reply can be seen on the textbox
                as shown.

            </dd>

            <h4>Test plans</h4>
            <dd>
                We have prepared the following tests for this particular model:
                <ol>
                    <li><a href="../sprint1_project/test/kotlin/TestUtilityMethods.kt">TestUtilityMethods.kt</a>: it checks the validity 
                    of the utils.kt object by testing its methods.</li>
                    <li><a href="../sprint1_project/test/kotlin/TestTrolleyMover.kt">TestTrolleyMover.kt</a>: it checks if the movements 
                    needed to accomplish the tasks are done correctly and tests an instance of interrupted movement due to a change of the 
                    target destination, that also must be handled in the correct order.</li>
                    <li><a href="../sprint1_project/test/kotlin/TestTransporttrolley.kt">TestTransporttrolley.kt</a>: it checks if both single
                    and consecutive requests are managed in the correct way by the transporttrolley using CoaP to keep track of it's movements.
                    <li><a href="../sprint1_project/test/kotlin/TestWasteservice.kt">TestWasteservice.kt</a>: it simply checks if the requests
                    made to the wasteservice are accepted or denied accordingly to the state of the system.
                </ol>
            </dd>
        </div>

         <!--TODO: SOSTITUIRE NOMI di exec + planner NEI FILE-->

        <h2>Work plan</h2>
      
        While <kc>Sprint 1</kc> focused on the core systems of the <b>waste service</b>, in <kc>Sprint 2</kc> we will tackle the <b>raspberry</b>
        portion on the interaction with the robot.<br/>

        <!--TODO: Immagine con parte raspberry evidenziata-->
        
        SCRUM Goal:
        <ol>
            <li>Add a <kl>HALT</kl> functionality to the robot's behavior</li>
            <li>Connect the <b>raspberry</b> to the system</li>
            <li>Implement the <k>sonar</k> interaction</li>
            <li>Implement the <k>led</k> interaction</li>
        </ol>

        <h5>Next Sprint: <kc href=""><kc>Sprint 2</kc></a></h5>


        <h2>Task assignment</h2>

        <table class="center">
            <tr>
                <th>Task</th>
                <th>Description</th>
                <th>Developers</th>
            </tr>
            <tr>
                <td><center>Implementation of Coordinate features</center></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><center>Implementation of new and updated actors</center></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><center>Implementation of Path Switching feature</center></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td><center>Smart Device development</center></td>
                <td>Creating a mini-app that simulates the Truck Driver interaction with the wasteservice.</td>
                <td></td>
            </tr>
            <tr>
                <td><center> Wasteservice Testing</center></td>
                <td>Creating test routines for the wasteservice actor, implementing CoaP communication as a monitoring tool</td>
                <td></td>
            </tr>
            <tr>
                <td><center> Transporttrolley Testing</center></td>
                <td>Creating test routines for the transporttrolley actor, implementing CoaP communication as a monitoring tool</td>
                <td></td>
            </tr>
            <tr>
                <td><center> Trolleymover Testing</center></td>
                <td>Creating test routines for the trolleymover actor, implementing CoaP communication as a monitoring tool</td>
                <td></td>
            </tr>
        </table>

       

    </div>

    <!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->

    <br /><br />
    </div>

    <div style="background-color:rgba(185, 180, 215, 0.9); width:100%;text-align:center;color:white">
        By <a href="https://github.com/TeamFAG/ISS-WasteService">TeamFAG</a>: <br />
        <a href="https://github.com/Federicoand98">federico.andrucci@studio.unibo.it</a>,<br />
        <a href="https://github.com/Noesh">alex.gianelli@live.it</a>,<br />
        <a href="https://github.com/Stikinit">gabriele.marconi@studio.unibo.it</a>,<br />

        <br />

        <table class="noborder">
            <tr class="noborder">
                <th class="noborder">
                    Federico Andrucci
                </th>
                <th class="noborder">
                    Alex Gianelli
                </th>
                <th class="noborder">
                    Gabriele Marconi
                </th>
            </tr>
            <tr class="noborder">
                <td class="noborder">
                    <img src="./imgs/federico-andrucci.jpg" alt="f" style="width:300;height:auto;" class="center">
                </td>
                <td class="noborder">
                    <img src="./imgs/alex-gianelli.jpg" alt="a" style="width:300;height:auto;" class="center">
                </td>
                <td class="noborder">
                    <img src="./imgs/gabriele-marconi.jpg" alt="g" style="width:300;height:auto;" class="center">
                </td>
            </tr>
        </table>
    </div>
</body>

</html>